Sorting
==========
## 기준에 따라 데이터를 정렬
### 정렬 알고리즘 개요
- 정렬이란?
  - 데이터를 특정한 기준에 따라서 순서대로 나열하는 것.
  - 프로그램을 가장 많이 사용되는 알고리즘 중 하나.

### 선택 정렬
- 만약 작은 순서대로 정렬한다면?
  - 가장 작은 데이터를 선택해 맨 앞에 데이터와 바꾸고, 그 다음 데이터를 선택해 두번째 데이터와 바꾸는 것을 반복.
    - 즉, 매번 가장 작은 것을 선택.
  ```python
  arr = [7, 5, 4, 0, 3, 1, 6, 2, 9, 8]

  for i in range(len(arr)):
    minidx = i
    for j in range(i+1, len(arr)):
        if arr[minidx] > arr[j]:
            minidx = j
    arr[i], arr[minidx] = arr[minidx], arr[i] # 선택된 원소를 i ~ len(arr) 구간에서 가장 앞으로 보냄.

  print(arr)
  ```

- **선택 정렬의 시간 복잡도**
  - 선택정렬은 N-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보냄.
  - 또한 매번 비교 연산이 필요함.
  - $O(n^2)$
  - 2중 반복문이 사용됨.

### 삽입 정렬
- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 알고리즘.
- 필요할 때만 위치를 바꿈. 데이터가 비교적 정렬되어 있을 때 효율적임. 
- 선택 정렬에 비해 구현 난이도는 높지만, 실행 시간 측면에서 효율적.
- 정렬이 이루어진 원소는 항상 특정 차순을 유지하고 있음.
  
  ```python
  arr = [7, 5, 4, 0, 3, 1, 6, 2, 9, 8]

  for i in range(1, len(arr)): # 첫번째 원소는 이미 정렬되어 있다고 가정.
    minidx = i
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 감소하면서 반복함. 시작 원소까지 반복해야하는 특징이 있음.
        if arr[j] < arr[j-1]: # 한칸씩 왼쪽으로 이동함. 
            arr[j], arr[j-1] = arr[j-1], arr[j]
        else:
            break

  print(arr)
  ```
  - range의 세번째 매개 변수
    > range의 매개 변수는 3개 (start, end, step)이다. 세 번째 매개 변수인 step에 -1이 들어가면 start 인덱스부터 시작해서 end+1 인덱스까지 1씩 감소한다. 앞의 코드에서는 j 변수가 i부터 1까지 1씩 감소한다.




- **삽입 정렬의 시간복잡도**
  - 선택 정렬과 반복문이 두 번 중첩되어 사용됨.
  - $O(n^2)$
  - 리스트가 거의 정렬되어 있는 상태라면 매우 빠르게 동작함.

### 퀵 정렬
- 가장 많이 사용되는 알고리즘.
- 퀵 정렬과 병합 정렬이 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘.
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법.
  - 기준을 설정한 다음, 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작함.
- 퀵 정렬은 **피벗(pivot)** 데이터를 기준으로 사용됨.
- 피벗 데이터를 기준으로 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾음.
- 이후 큰 데이터와 작은 데이터의 위치를 서로 교환.
- 일반적인 퀵정렬 소스코드

  ```python
  arr = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(arr, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and arr[left] <= arr[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and arr[right] >= arr[pivot]:
            right -= 1
        if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
            arr[right], arr[pivot] = arr[pivot], arr[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(arr, start, right-1)
    quick_sort(arr, right+1, end)

  quick_sort(arr, 0, len(arr)-1)
  print(arr)
  ```
- 파이썬의 장점을 살린i 퀵정렬 소스코드
  ```python
  arr = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(arr):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(arr) <= 1:
        return arr

    pivot = arr[0] # 피벗은 첫 번째 원소
    tail = arr[1:] # 피벗을 제외한 리스트
  
    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환.
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

  print(quick_sort(array))
  ```
- 퀵 정렬의 시간 복잡도
  - $O(nlog(n))$
  - 데이터 개수가 많을 수록 퀵정렬이 압도적으로 빠르게 동작함.

### 계수 정렬
- 특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘.
- 특정 조건이란?
  - 데이터 크기 범위가 제한되어 정수 형태로 표현할 수 있는 데이터.
  - 데이터 간 간격이 매우 넓다면(예를 들어, [0, 100001]과 같은 리스트), 비효율적인 정렬 방법.
  - 왜냐하면 모든 범위를 담을 수 있는 크기의 리스트(count_list)를 선언해야 하기 때문.
- 앞서 다루었던 3가지 정렬 알고리즘처럼 직접 데이터 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식이 아님.
  ```python
  # 모든 원소의 값이 0보다 크거나 같은 자료형일때.
  arr = [5, 9, 0, 1, 6, 2, 9, 1, 8, 0, 2]
  # 모든 범위를 포함하는 리스트 선언(이때, 모든 값은 0으로 초기화)
  cnt_lst = [0] * (max(arr + 1))

  for i in range(len(arr)):
    cnt_lst(arr[i]) += 1 # 각 데이터에 해당하는 인덱스 값 증가

  for i in range(len(cnt_lst)): # 리스트에 기록된 정보 확인.
    for j in range(cnt_lst[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
  ```
- 계수 정렬의 시간복잡도
  - $O(n + k)$
  - 데이터의 범위만 한정되어 있면 효과적으로 사용할 수 있고, 항상 빠르게 동작함.

### 파이썬 정렬 라이브러리
- 파이썬은 sorted() 함수를 제공. 이는 병합 정렬을 기반으로 만들어짐.
- 집합 자료형이나 딕셔너리 자료형을 입력받아도 반환되는 결과는 리스트 자료형임.
- 정렬 라이브러리의 시간복잡도
  - 항상 최악의 경우에도 $O(nlog(n))$을 보장함.