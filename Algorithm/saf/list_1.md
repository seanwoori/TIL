APS 기본
=========

## 알고리즘
- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.
  - 어떠한 문제를 해결하기 위한 절차
- 무엇이 좋은 알고리즘인가?
  - 정확성 : 얼마나 정확하게 동작하는가 
  - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  - 단순성 : 얼마나 단순한가
  - 최적성 : 더이상 개선할 여지없이 최적화되었는가

### 알고리즘의 성능은 무엇으로 측정하는가?
- 시간복잡도 (Time Complexity)
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산
- 빅-오(O) 표기법
  - 시간복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  - 계수는 생략하여 표시
  - 예시)
    $$O(3n+2) = O(3n) = O(n)$$
    $$O(2n^2+10n+100) = O(n^2) = O(1)$$
  - n개의 데이터를 입력받아 저장. 이후 각 데이터에 1씩 증가시킨 후 화면에 출력하는 알고리즘의 시간 복잡도는? $O(n)$


### 알고리즘 문제풀이
- 문제 풀이에는 왕도가 없음.
- 문제 풀이의 단계
  - 문제 읽기 (웹툰이나 소설 읽듯이 가볍게 읽어 줄거리 잡기)
  - 접근방법을 구상하기
    - 사람의 방법(병렬적 방법)이 아닌 컴퓨터의 방법(loop적인 방법)으로 구상하기
  - **핵심코드 손코딩해보기 (손으로 정답을 내보기. 변수나 범위를 실명으로, 시각적으로 구체적으로 구현하기)**
  - 코드구현
  - 디버깅 및 개선(pycharm과 같은 디버거 툴 적극적 활용, 제출 완료한 코드라도 간략화하도록 노력)
### 접근방법 구상
- 완전히 새로운 문제는 없음.
  - 이전 풀었던 문제와 유사한지, 특정 자료구조 적용, 전형적인 알고리즘 적용 가능한지.
- 문제가 시키는 대로 시도
  - 문제 설명대로 예시를 처리하는 것이 접근 가능한지 체크(제한 조건 내)
  - 여러 입력에 대한 출력을 계산하면서 [규칙성/조건/수식] 적용 가능한지 체크
- 유형/규칙성을 발견하기 힘들다면...
  - 가능한 모든 경우를 처리하면서 풀이 가능한지 체크
  - 전체 문제가 아닌 일부분으로 나누거나, 단계를 나누어 접근
  - **반대로 접근**하는 경우를 체크
- **이 모든 접근은 시각적으로(손으로 그리면서)** => 실수를 줄일 수 있음.

### 문제풀이 연습
- 기본기는 철저히 연습
  - 기본기가 탄탄해야 구상한 아이디어를 실수 없이 구현 가능
  - 정확한 **입출력**, 실수 없는 **2차원 array** 사용 및 **다중 루프제어**
  - 가장 효율적인/짧은/멋있는 코드보다 **기본적인 [반복/조건]**을 빈틈없이 구현
  - **손코딩** : 사용하는 주요 array, **범위**, 핵심코드를 실명/시각적으로 설계하고 접근
  - 필요한 위치에서 필요한 디버깅 가능하도록 디버거 사용법 숙지
  - 문제읽기 -> 접근방법 구상 -> 핵심코드 손코딩 (키보드를 멀리하세요)